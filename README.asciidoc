= infinispan-queryable-custom-loader
Creating a Custom Loader that also provides Queryable object in DataGrid

This repository contains step by step instructions of how to get a custom loader working with querying. Each step is accompanied by a related commit that shows progress.

NOTE: This project is not meant to be checked out, but to create a project for yourself and can follow step by step

== Steps

. (Optional) Configure a maven-settings.xml to point to a local repository if needed.
The repository comes with an empty one (example-maven-settings.xml) that can be used by replacing the directory location of the location on the filesystem.
All subsequent commands will assume this is done, you can remove all subsequent "-s maven-settings.xml" references if this
was not done.
. Generate the store archetypes (substitute the version as appropriate). Note the verison is not the same as DataGrid, but rather
specific to the archetype. As of this writing the current version is 1.0.25.
+
```
mvn -s maven-settings.xml archetype:generate \
     -DarchetypeGroupId=org.infinispan.archetypes \
     -DarchetypeArtifactId=store-archetype  \
     -DarchetypeVersion=<version>
```
+
This command will eventually prompt the user for a groupId, artifactId, project version and package. Please populate as appropriate for the usage.
This example will use test, cacheloader, 1.0-SNAPSHOT and test.cacheloader.impl respectively.
+
You should now have a cacheloader directory in the current directory that contains a pom.xml and several children modules, one per type of custom loader/store.
To simplify the project all the contents of cacheloader will be moved to the root directory.
In this example we will be using the cache-loader project moving forward.
+
NOTE: You may notice that the generated projects do not compile, we will be fixing this in the next step
+
. Adding DataGrid dependencies to the base project
.. Configure Infinispan bom to parent pom
+
Add the following snippet to the pom.xml in the root directory replacing 9.4.11.Final with the appropriate version
+
```xml
   <parent>
      <groupId>org.infinispan</groupId>
      <artifactId>infinispan-bom</artifactId>
      <version>9.4.11.Final</version>
   </parent>
```
.. Replace Infinispan embedded dependency with core and add protostream dependency
+
```xml
      <dependency>
         <groupId>org.infinispan</groupId>
         <artifactId>infinispan-core</artifactId>
         <scope>provided</scope>
      </dependency>

      <dependency>
         <groupId>org.infinispan.protostream</groupId>
         <artifactId>protostream</artifactId>
         <scope>provided</scope>
      </dependency>

```
+
NOTE: The dependency is marked as provided scope, since the Infinispan server will provide those classes automatically and aren't needed in a built jar.
.. (Optional) Remplace metainf version to use bom. Remove version.metainf property.
+
```xml
      <dependency>
         <groupId>org.kohsuke.metainf-services</groupId>
         <artifactId>metainf-services</artifactId>
         <version>${version.metainf-services}</version>
         <scope>provided</scope>
      </dependency>
```
+
NOTE: The dependency is marked as provided scope, this is due to this dependency only being required for compile and is not used at runtime
+
. Setup configuration classes, allows for parameters via xml
.. We start by removing some redundant classes. These are only useful in embedded mode, which we are using server
... Attribute.java
... CustomStoreConfigurationParser.java
... Element.java
.. Now the various configuration parameters need to be added to the following classes
+
Here is an example of adding a name and age to our configuration
+
... CustomStoreConfiguration.java
+
```java
@BuiltBy(CustomStoreConfigurationBuilder.class)
@ConfigurationFor(CustomCacheLoader.class)
public class CustomStoreConfiguration extends AbstractStoreConfiguration {

    static final AttributeDefinition<String> NAME = AttributeDefinition.builder("name", null, String.class).immutable().build();
    static final AttributeDefinition<Integer> AGE = AttributeDefinition.builder("age", 0, Integer.class).immutable().build();

    private final Attribute<String> name;
    private final Attribute<Integer> age;

    public static AttributeSet attributeDefinitionSet() {
        return new AttributeSet(CustomStoreConfiguration.class, AbstractStoreConfiguration.attributeDefinitionSet(), NAME, AGE);
    }

    public CustomStoreConfiguration(AttributeSet attributes, AsyncStoreConfiguration async, SingletonStoreConfiguration singletonStore) {
        super(attributes, async, singletonStore);
        name = attributes.attribute(NAME);
        age = attributes.attribute(AGE);
    }

    public String name() {
        return name.get();
    }

    public Integer age() {
        return age.get();
    }
}
```
... CustomStoreConfigurationBuilder.java
+
```java
public class CustomStoreConfigurationBuilder extends AbstractStoreConfigurationBuilder<CustomStoreConfiguration, CustomStoreConfigurationBuilder>{

    public CustomStoreConfigurationBuilder(
          PersistenceConfigurationBuilder builder) {
        super(builder, CustomStoreConfiguration.attributeDefinitionSet());
    }

    public CustomStoreConfigurationBuilder name(String name) {
        attributes.attribute(NAME).set(name);
        return this;
    }

    public CustomStoreConfigurationBuilder age(int age) {
        attributes.attribute(AGE).set(age);
        return this;
    }

    @Override
    public CustomStoreConfiguration create() {
        return new CustomStoreConfiguration(attributes.protect(), async.create(), singletonStore.create());
    }

    @Override
    public CustomStoreConfigurationBuilder self() {
        return this;
    }
}
```
+
.. The CustomCacheLoader can inject the configuration in the init method
+
This can then be used in an invocation later
+
```java
    CustomStoreConfiguration config;
   
    @Override
    public void init(InitializationContext ctx) {
        config = ctx.getConfiguration();
    }
```
